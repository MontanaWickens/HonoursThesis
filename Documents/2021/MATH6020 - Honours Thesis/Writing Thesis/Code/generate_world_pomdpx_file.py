import numpy as np
import xml.dom.minidom
import argparse
import world_model_functions as f


if __name__ == "__main__":
 
    ### parse arguments
    parser = argparse.ArgumentParser(description='pomdpx file generator',
            formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("-v", "--verbose", action="store_true",
            help="increase output verbosity")
    parser.add_argument('-a', type=int, action="store", dest='a', default=6)
    parser.add_argument('-s', type=int, action="store", dest='s', default=3)
    parser.add_argument('-o', type=int, action="store", dest='o', default=5)
    parser.add_argument('-K', type=int, action="store", dest='K', default=300000)
    parser.add_argument('-k', type=int, action="store", dest='k', default=2)
    parser.add_argument('-R', type=int, action="store", dest='R', default=5)
    parser.add_argument('-r', type=int, action="store", dest='r', default=2)
    parser.add_argument('-B', type=int, action="store", dest='B', default=300000)
    parser.add_argument('-c', type=int, action="store", dest='c', default=40000)
    parser.add_argument('-p', type=int, action="store", dest='p', default=9.76)
    
    args = parser.parse_args()

    np.random.seed(2)
 
    # read in command line arguments for the following parameters
    cost_of_stock_assessment = args.c
    N_a = args.a #Number of actions
    N_B = args.s #Number of biomass intervals
    N_K = args.k #Number of K intervals
    N_R = args.r #Number of R intervals
    K_max = args.K #Maximum K
    R_max = args.R #Maximum R
    B_max = args.B #Maximum biomass
    profit = args.p #Price of unit biomass
    num_simulation = 100
    
    # true popualtion parameters
    Rstar, Kstar, Bstar = 3, 300000, 150000

    # discretisation of states, observations and actions
    catch_vector = [(i*B_max/N_B,(i+1)*B_max/N_B) for i in range(N_B)]
    biomass_vector = [(i*B_max/N_B,(i+1)*B_max/N_B) for i in range(N_B)]
    K_vector = [100000 + i*100000 for i in range(N_K + 1)]
    r_vector = [1 + i*1 for i in range(N_R+1)]
    # K_vector = [i*K_max/N_K for i in range(N_K +1)]
    # r_vector = [i*R_max/N_R for i in range(N_R +1)]
    observations_vector = [(catch,biomass,capacity,proliferation) for catch in catch_vector
                                                            for biomass in biomass_vector
                                                            for capacity in K_vector
                                                            for proliferation in r_vector]
    action_vector = [i/(N_a-1) for i in range(N_a-1)]+[1]
    states_vector = [(biomass,action,capacity,proliferation) for biomass in biomass_vector
                                                             for action in action_vector
                                                             for capacity in K_vector
                                                             for proliferation in r_vector]
    N_S = len(states_vector)
    N_O = len(observations_vector)
    N_a = len(action_vector)
    
    # printing
    print('\nCost of completing stock assessment: ', cost_of_stock_assessment)
    print('Number of biomass intervals: ', args.s)
    print('Number of actions: ', N_a)
    print('Number of observations: ', N_O)
 
    # initial belief
    belief = f.initial_belief(states_vector)

    # state transition matrix
    transition = f.discrete_BH_transition(states_vector, action_vector, Rstar, Kstar)
    
    # observation transition matrix
    obs_probs = f.observation_function(states_vector, action_vector, observations_vector, Rstar, Kstar, Bstar)

    ### write pomdpx file
    text = []
    text.append('<pomdpx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="0.1" id="autogenerated" xsi:noNamespaceSchemaLocation="pomdpx.xsd">')
    ## description
    text.append('<Description>Stock Assessment Decisions with Multiplicative Harvest</Description>')
    ## discount
    text.append('<Discount>0.95</Discount>')

    ## variables
    # state: stock size and harvest rate
    text.append('<Variable>'
          '<StateVar vnamePrev="b-h_0" vnameCurr="b-h_1" fullyObs="false">'
          '<NumValues>' + str(len(states_vector)) + '</NumValues>'
          '</StateVar>')

    # observation: catch
    text.append('<ObsVar vname="catch">'
          '<NumValues>' + str(len(observations_vector)) + '</NumValues>'
          '</ObsVar>')

    # action
    text.append('<ActionVar vname="model_A_stock_assessment_decision">'
          '<NumValues>' + str(len(action_vector)) + '</NumValues>'
          '</ActionVar>')

    text.append('<RewardVar vname="reward_agent"/>')
    text.append('</Variable>')

    ## initial belief
    text.append('<InitialStateBelief>'
          '<CondProb>'
          '<Var>b-h_0</Var>'
          '<Parent>null</Parent>'
          '<Parameter type="TBL">'
          '<Entry>'
          '<Instance>-</Instance>'
          '<ProbTable>' + ' '.join(belief.astype(str)) + '</ProbTable>'
          '</Entry>' 
          '</Parameter>'
          '</CondProb>'
          '</InitialStateBelief>')
    
    # state transition
    text.append('<StateTransitionFunction>'
          '<CondProb>' 
          '<Var>b-h_1</Var>'
          '<Parent>model_A_stock_assessment_decision b-h_0</Parent>'
          '<Parameter type="TBL">')

    for a in range(N_a):
        for s0 in range(N_S):
            for s1 in range(N_S):
                text.append('<Entry>'
                      '<Instance>' + ('a%d s%d s%d' % (a, s0, s1)) + '</Instance>'
                      '<ProbTable>' + str(transition[a, s0, s1]) + '</ProbTable>'
                      '</Entry>')

    text.append('</Parameter>'
          '</CondProb>' 
          '</StateTransitionFunction>')

    # observation transition
    text.append('<ObsFunction>'
          '<CondProb>' 
          '<Var>catch</Var>'
          '<Parent>model_A_stock_assessment_decision b-h_1</Parent>'
          '<Parameter type="TBL">')

    for a in range(N_a):
        for s in range(N_S):
            for o in range(N_O):
                text.append('<Entry>' 
                    '<Instance>' + ('a%d s%d o%d' % (a, s, o)) + '</Instance>'
                    '<ProbTable>' + str(obs_probs[a, s, o]) + '</ProbTable>' 
                    '</Entry>')

    text.append('</Parameter>'
          '</CondProb>'
          '</ObsFunction>')

    # reward
    text.append('<RewardFunction>'
          '<Func>' 
          '<Var>reward_agent</Var>'
          '<Parent>model_A_stock_assessment_decision b-h_1</Parent>'
          '<Parameter type="TBL">')

    for a in range(N_a):
        for s1 in range(N_S):
            reward = f.reward_function(action_vector[a],states_vector[s1],cost_of_stock_assessment,profit)
            text.append('<Entry>'
                '<Instance>' + ('a%d s%d' % (a,s1)) + '</Instance>'
                '<ValueTable>' +
                str(reward) + '</ValueTable>'
                '</Entry>')

    text.append('</Parameter>'
          '</Func>'
          '</RewardFunction>')
    text.append('</pomdpx>')

    import os
    filename = os.path.join(os.getcwd(), "a%d-s%d-r%d-k%d_modelB.pomdpx" % (args.a, args.s, args.r, args.k))
    print('\n Writing to POMDPX file')
    with open(filename, 'w') as f:
        dom =xml.dom.minidom.parseString(''.join(text))
        f.write(dom.toprettyxml())
    print('generated %s \n' % (filename))

# save variables for plotting
np.save('transition_world_model.npy', transition) 
np.save('obs_prob_world_model', obs_probs)
np.save('biomass_vector_world_model.npy', biomass_vector)
np.save('actions_vector_world_model.npy', action_vector)
np.save('K_vector_world_model.npy', K_vector)
np.save('r_vector_world_model.npy', r_vector)
